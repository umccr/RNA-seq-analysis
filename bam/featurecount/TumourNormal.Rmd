---
title: "FC work with the recount2 pancreatic samples"
author: "Sehrish Kanwal"
date: "`r format(Sys.time(), '%a %Y-%b-%d')`"
output: 
  html_document: 
    keep_md: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Required R packages

```{r, message=FALSE}
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(ggplot2)
library(dplyr)
library(reshape)
options(width = 140)
library(ggrepel)
```

## Preparing Tumour Data

```{r}
seqdata_t <- read.delim("~/Documents/UMCCR/data/fpkm/featurecount_Unknown_B", stringsAsFactors = FALSE, comment.char = "#")
dim(seqdata_t)

# New object that contains just the counts
countdata_t <- seqdata_t[,8, drop = FALSE]
head(countdata_t)
dim(countdata_t) 

# Add rownames i.e. GeneIDs to data
rownames(countdata_t) <- seqdata_t[,1]
head(countdata_t)

# Rename column heading for sample
colnames(countdata_t) <- c("Tumour")
head(countdata_t)

# Filtering to remove low expressed genes. The cpm function also adds a small offset to avoid taking log of zero.
myCPM <- cpm(countdata_t)
head(myCPM)

# Which values in myCPM are greater than 0.15?
thresh <- myCPM > 0.15

# This produces a logical matrix with TRUEs and FALSEs
head(thresh)

# Summary of how many TRUEs there are in each row.
table(rowSums(thresh))

# Would like to keep genes that have TRUE thresh value in each row of thresh
keep <- thresh == TRUE

# Subset the rows of countdata to keep the more highly expressed genes
counts_keep_t <- countdata_t[keep, ,  drop = FALSE]

# Converting row names to first coloumn
# counts_keep_t <- tibble::rownames_to_column(counts_keep_t, "gene_id")

# Taking a look at the subset data
summary(keep)
head(counts_keep_t)
dim(counts_keep_t)
str(counts_keep_t)

# Convert counts to DGEList object. First, create a DGEList object. This is an object used by edgeR to store count data. It has a number of slots for storing various parameters about the data.
y <- DGEList(counts_keep_t)

# have a look at y
y

# See what slots are stored in y
names(y)

# Library size information is stored in the samples slot
y$samples

# Get log2 counts per million
logcounts_t <- cpm(y,log=TRUE)

# have a look at logcounts
head(logcounts_t)
dim(logcounts_t)
```

## Preparing Normal Data

```{r}
# Downloaded pancreatic data from https://jhubiostatistics.shinyapps.io/recount/. Read in the data.
countdata <- read.delim("~/Documents/UMCCR/data/recount2/counts_gene_pan.tsv", stringsAsFactors = FALSE, comment.char = "#")
dim(countdata)
head(countdata)

# Rearranging columns to have gene_id in a diff dataframe as that is not a numeric coloumn and the subsequent analysis assumes that the coloumns have numeric values. For now adding gene_ids as rownames.
countdata_n <- countdata[, c(1, 2, 3, 4)]
head(countdata_n)
rownames(countdata_n) <- countdata[,5]

# Filtering to remove low expressed genes. The cpm function also adds a small offset to avoid taking log of zero.
myCPM <- cpm(countdata_n)

# Which values in myCPM are greater than 0.15?
thresh <- myCPM > 0.15

# This produces a logical matrix with TRUEs and FALSEs
head(thresh)

# Summary of how many TRUEs there are in each row.
table(rowSums(thresh))

# Would like to keep genes that have that have at least 2 TRUES in each row of thresh
keep <- rowSums(thresh) >= 2

# Subset the rows of countdata to keep the more highly expressed genes
counts_keep_n <- countdata_n[keep, ,  drop = FALSE]


# Taking a look at the subset data
summary(keep)
head(counts_keep_n)
dim(counts_keep_n)
str(counts_keep_n)

# Convert counts to DGEList object. First, create a DGEList object. This is an object used by edgeR to store count data. It has a number of slots for storing various parameters about the data.
y <- DGEList(counts_keep_n)

# have a look at y
y

# See what slots are stored in y
names(y)

# Library size information is stored in the samples slot
y$samples

# Get log2 counts per million
logcounts_n <- cpm(y,log=TRUE)

# have a look at logcounts
head(logcounts_n)
dim(logcounts_n)
```

## Comparing tumour sample VS panel of normals

```{r}
# Merging count data from tumour sample and normal samples. 
counts_merged <- merge(logcounts_n, logcounts_t, by="row.names")
dim(counts_merged)
head(counts_merged)
rownames(counts_merged)= counts_merged$Row.names
counts_merged <- counts_merged[,2:6]

# Starting the actual analysis. Creating a design matrix first.
design <-  cbind(c(1,1,1,1,0), c(0,0,0,0,1))

# Assigning rownames and column names
rownames(design) <- c("C1", "C2", "C3", "C4", "T")
colnames(design) <- c("WT", "MU")

fit <- lmFit(counts_merged, design)
cont.matrix <- makeContrasts(MUvsWT=MU-WT, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
result <- topTable(fit2, adjust="BH", number = Inf)
```


## Plotting result

1. ecdf

```{r}
#Preparing quartiles
q1 <- quantile(result$logFC)[2]
q2 <- 0
q3 <- quantile(result$logFC)[4]

#Making a tibble from quartiles
events <- data_frame(quartiles = c(q1,q2,q3),
                     text = c('Q1','','Q3'))

# Plot stat_ecdf for kallisto 
p <- ggplot(result, aes(result$logFC)) + 
  stat_ecdf(geom = "step", size = 0.25) + 
  geom_vline(data = events, aes(xintercept = events$quartiles), color = "blue", linetype="dotted") +
  geom_text(data = events, mapping = aes(label = events$text, y = 0, x = quartiles), family="Times", size = 3, hjust = 0) +
  geom_point(aes(x=result["ENSG00000136997", 1], y=0.963 , colour = "yellow"), show.legend = FALSE, label="MYC") +
  geom_text(aes(x=5.67, label="MYC", y=0.93), family="Times", size = 3) +
  coord_cartesian(xlim = c(-5, 10)) +
  labs(title="Empirical Cumulative Density Function", y = "cumulative fraction", x="gene log2 fold change", family="Times")
p
```

## To do -> Fix mds plot and add z-transformation

2. mds

```{r, eval=FALSE}
sampleinfo <- data.frame(c('ERR674422','ERR674425','ERR674419', 'ERR674424', 'Tumour'), c('pancreatic', 'pancreatic', 'pancreatic', 'pancreatic', 'tumour'), c('normal', 'normal', 'normal', 'normal', 'tumour'))
colnames(sampleinfo) <-  c("SampleName", "CellType", "Status")
levels(sampleinfo$CellType)
col.cell <- c("purple","orange")[sampleinfo$CellType]
data.frame(sampleinfo$CellType,col.cell)

# Redo the MDS with cell type colouring
plotMDS(y,col=col.cell)
# Let's add a legend to the plot so we know which colours correspond to which cell type
legend("topleft",fill=c("purple","orange"),legend=levels(sampleinfo$CellType))
# Add a title
title("Cell type")
```




