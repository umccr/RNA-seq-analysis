---
title: "Investigate expression data distribution for selected genes"
author: "UMCCR"
date: "`r format(Sys.time(), '%d %B, %Y')`"
params:
  exprDir: '~/Documents/UMCCR/data/RNAseq-report/ExpressionData'
  exprFile: 'UMCCR_PC.counts.matrix.txt.subset.txt'
  annotFile: 'UMCCR_PC_Target_cleaned.txt'
  transform: 'TPM'
  norm: 'None'
  log: TRUE
  genes: 'ENSG00000148773,ENSG00000133703,ENSG00000141646,ENSG00000147889,ENSG00000141510'
  results_name: 
  ensembl_version: 86
output:
  html_document:
    keep_md: yes
    code_folding: hide
#    toc: true
#    toc_float: true
---

The aim of this report is investigate the expression data distribution patters of all or user-defined genes in combined expression data (**`r params$exprFile`**) derived from different samples. The data combination includes transformation (`r params$transform` method, `r if ( !params$log ) { c("with no log-transformation") } else if ( params$log ) { c("followed by log2-transformation") }`) and normalisation (`r params$norm`). The pipeline is based on recommendations from *[RNAseq123](https://master.bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html){target="_blank"}* package.

```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
### Define functions

##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0
##### Prepare object to write into a file
prepare2write <- function (x) {
  
  x2write <- cbind(rownames(x), x)
  colnames(x2write) <- c("Gene",colnames(x))
  return(x2write)
}
##### Prepare gene data matrix to write into a file
geneMatrix2write <- function (x) {
  
  x2write <- cbind(rownames(x), x)
  colnames(x2write) <- c("Gene",colnames(x))
  return(x2write)
}

##### Assign colours to different groups
getTargetsColours <- function(targets) {
  
  ##### Predefined selection of colours for groups
  targets.colours <- c("red","blue","green","darkgoldenrod","darkred","deepskyblue", "coral", "cornflowerblue", "chartreuse4", "bisque4", "chocolate3", "cadetblue3", "darkslategrey", "lightgoldenrod4", "mediumpurple4", "orangered3","indianred1","blueviolet","darkolivegreen4","darkgoldenrod4","firebrick3","deepskyblue4", "coral3", "dodgerblue1", "chartreuse3", "bisque3", "chocolate4", "cadetblue", "darkslategray4", "lightgoldenrod3", "mediumpurple3", "orangered1")
  
  f.targets <- factor(targets)
  vec.targets <- targets.colours[1:length(levels(f.targets))]
  targets.colour <- rep(0,length(f.targets))
  for(i in 1:length(f.targets))
    targets.colour[i] <- vec.targets[ f.targets[i]==levels(f.targets)]
  
  return( list(vec.targets, targets.colour) )
}

##### Assign colours to different groups
getGenesColours <- function(genes) {
  
  ##### Predefined selection of colours for genes
  genes.colours <- rainbow(length(genes))

  f.genes <- factor(genes)
  vec.genes <- genes.colours[1:length(levels(f.genes))]
  genes.colour <- rep(0,length(f.genes))
  for(i in 1:length(f.genes))
    genes.colour[i] <- vec.genes[ f.genes[i]==levels(f.genes)]
  
  return( genes.colour )
}

##### Calculate TPM from RPKM (from http://luisvalesilva.com/datasimple/rna-seq_units.html )
tpm_from_rpkm <- function(x) {
  rpkm.sum <- colSums(x)
  return(t(t(x) / (1e-06 * rpkm.sum)))
}
```

```{r load_libraries, warning=FALSE}
### Load libraries
suppressMessages(library(preprocessCore))
suppressMessages(library(edgeR))
suppressMessages(library(tidyverse))
suppressMessages(library(package=paste0("EnsDb.Hsapiens.v", params$ensembl_version), character.only = TRUE))
suppressMessages(library(plotly))
```

```{r load_data, message=FALSE, warning=FALSE}
##### Read in expression data and associated sample annotation files
data <- read.table(paste(params$exprDir, params$exprFile, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names = 1)
targetFile <- read.table(paste(params$exprDir, params$annotFile, sep="/"), sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]

##### Make sure that there are no duplciated samples in the target file
targetFile <- targetFile[!duplicated(targetFile[,"Sample_name"]),]
rownames(targetFile) <- targetFile[,"Sample_name"]

##### Make syntactically valid names
colnames(data) <- make.names(colnames(data))
rownames(targetFile) <- make.names(rownames(targetFile))

##### Make sure that the target file contains info only about samples present in the data matrix
targetFile <- targetFile[ rownames(targetFile) %in% colnames(data),  ]

##### Make sure that the samples order in the data matrix is the same as in the target file. If the expression matrix contains data for additional samples then write the data subset (containing only samples from the target file) into a file
if ( !all( colnames(data) %in% rownames(targetFile) , na.rm = FALSE)  ) {
  
  data <- data[ , rownames(targetFile) ]

  ##### Save data subset into a file
  write.table(geneMatrix2write(data), file=paste0(normalizePath(params$exprDir), "/", paste0(params$exprFile, ".subset.txt")), sep="\t", quote=FALSE, row.names=FALSE, append = FALSE)
}
```

***

## Library size

Bar-plot illustrating library size for each sample.

```{r library_size_plot, message = FALSE, warning=FALSE, fig.width = 12, fig.height = 9}
suppressMessages(library(plotly))
##### Generate bar-plot for library size. The colours indicate sample groups, as provided in *Target* column in the sample annotation file

##### Assigne colours to targets and datasets
targets.colour <- getTargetsColours(targetFile$Target)

##### Prepare data frame
data.df <- data.frame(targetFile$Target, colnames(data), as.numeric(colSums(data)*1e-6))
colnames(data.df) <- c("Group","Sample", "Library_size")

##### The default order will be alphabetized unless specified as below
data.df$Sample <- factor(data.df$Sample, levels = data.df[["Sample"]])
p <- plot_ly(data.df, x = ~Sample, y = ~Library_size, color = ~Group, type = 'bar', colors = targets.colour[[1]], width = 1000, height = 400) %>%
  layout(title = "", xaxis = list( tickfont = list(size = 10), title = ""), yaxis = list(title = "Library size (millions)"), margin = list(l=50, r=50, b=150, t=50, pad=4), autosize = F, legend = list(orientation = 'v', y = 0.5), showlegend=TRUE)

##### Print htmlwidget
p

##### Save the bar-plot as html (PLOTLY)
#htmlwidgets::saveWidget(as_widget(p), paste0(normalizePath(params$exprDir), "/", paste0(params$results_name, "_RNAseq_libSize.html")), selfcontained = TRUE)
##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

## Data transformation

The read count data is converted into **`r params$transform`**s using *[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html){target="_blank"}* functions. `r if ( !params$log ) { c("The data is not log-transformed") } else if ( params$log ) { c("The data is log2-transformed") }`. Plot(s) below present `r params$transform` data distribution.

```{r data_subset, comment = NA, message=FALSE, warning=FALSE}
##### Subset data to include only user-defined genes
if ( tolower(params$genes) != ("all")  ) {
  
  genes <- unlist(strsplit(params$genes, split=',', fixed=TRUE))
  
  ##### Identify user-defined genes that were not present in the expression matrix
  genes.missing <- genes[ genes %!in% rownames(data) ]

  genes <- genes[ genes %in% rownames(data)  ]
  
  data <- data[ genes,  ]
  
} else {
  
  genes <- rownames(data)
}

##### Write list of missing genes into a file
if ( length(genes) > 0 ) {
    write.table(prepare2write(genes), file = paste0(normalizePath(params$exprDir), "/", paste0(params$results_name, ".genes.txt")), sep="\t", quote=FALSE, row.names=TRUE, append = FALSE )
  
  runChunk <- TRUE
} else {
  runChunk <- FALSE
}

##### Write list of missing genes into a file
if ( exists("genes.missing") && length(genes.missing) > 0 ) {
  
  write.table(prepare2write(genes.missing), file = paste0(normalizePath(params$exprDir), "/", paste0(params$results_name, ".genes.missing.txt")), sep="\t", quote=FALSE, row.names=TRUE, append = FALSE )
}
```

```{r data_transformation, comment = NA, message=FALSE, warning=FALSE, eval = runChunk}
##### Transformation to CPM or TPM scale (see these blogs for details https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/ and https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/ ).  CPM = Counts Per Million,  TPM = Transcripts Per Kilobase Million.

##### CPM transformation
if ( params$transform == "CPM" ) {
  
  ##### Create EdgeR DGEList object
  y <- edgeR::DGEList(counts=data,  group=targetFile$Target)
  ##### Calculate normalization factors and  and transform the raw-scale to CPM. Add small offset to each observation to avoid taking log of zero
  y <- edgeR::calcNormFactors(y)
  y$transformed <- edgeR::cpm(y, normalized.lib.sizes=TRUE, log=params$log, prior.count=0.25)
  
##### TPM data transformation. We can convert RPKM to TPM in two different ways: from pre-calculated RPKM, by diving by the sum of RPKM values, or directly from the normalized counts. Here we calculate TPM starting from RPKM values computed using edgeR's rpkm function ( from http://luisvalesilva.com/datasimple/rna-seq_units.html )
##### TPM transformation with filtering
} else if ( params$transform == "TPM" ) {
  
  ##### Get genes lengths
  edb <- eval(parse(text = paste0("EnsDb.Hsapiens.v", params$ensembl_version)))
  
  gene.length <- lengthOf(edb, filter = GeneIdFilter(rownames(data)))
  
  ##### Check for which genes the lenght info is not available and remove them from the data
  genes.no_length <- rownames(data)[ rownames(data) %!in% names(gene.length)]
  data <- data[ rownames(data) %!in% genes.no_length, ]
  
  ##### Create EdgeR DGEList object
  y <- edgeR::DGEList(counts=data,  group=targetFile$Target)
  
  ##### Calculate normalization factors and convert data into RPKM
  y <- edgeR::calcNormFactors(y)
  y$transformed <- edgeR::rpkm(y, gene.length = gene.length, normalized.lib.sizes=TRUE, log=FALSE)
  
  ##### ... and then to TPM scale. Add small offset to each observation to avoid taking log of zero
  if ( params$log ) {
    
    y$transformed <- log2(tpm_from_rpkm(y$transformed+0.25))
  
  } else {
    
    y$transformed <- tpm_from_rpkm(y$transformed)
  }
}
```

```{r data_transformation_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, eval = runChunk}
##### Collect the most extreme density values for set the x-axis and y-axis boundaries
den.x <- density(y$transformed[,1])$x
den.y <- density(y$transformed[,1])$y

for (i in 2:ncol(y$transformed)) {
  
  den <- density(y$transformed[,i])
  den.x <- sort(c(den.x, den$x))
  den.y <- sort(c(den.y, den$y))
}

##### Transformed data distribution
plot(density(y$transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
title(main="Transformed data", xlab=params$transform)
abline(v=0, lty=3)
  
for (i in 2:ncol(y$transformed)){
  den <- density(y$transformed[,i])
  lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
}
legend("topright", legend=levels(factor(targetFile$Target)), fill=targets.colour[[1]], bty="n", bg = "transparent")
  
##### Save the plot as pdf file
pdf(paste0(normalizePath(params$exprDir), "/", paste0(params$results_name, "_transformation.pdf")), width=8, height=5)

plot(density(y$transformed[,1]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=targets.colour[[2]][1])
title(main="Transformed data", xlab=params$transform)
abline(v=0, lty=3)
  
for (i in 2:ncol(y$transformed)){
  den <- density(y$transformed[,i])
  lines(den$x, den$y, lwd=2, col=targets.colour[[2]][i])
}
legend("topright", legend=levels(factor(targetFile$Target)), fill=targets.colour[[1]], bty="n", bg = "transparent")
invisible(dev.off())
```

## Data normalisation

`r if ( tolower(params$norm) == "none" ) { c("No normalisation is performed") } else { c(paste0("During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effects is required to ensure that the expression distributions of each sample are similar across the entire experiment. Normalisation is performed using ", params$norm, " method")) }`. 

`r if ( tolower(params$norm) != "none" ) { c(paste0("Box-plots below present ", params$transform, " data for individual samples, coloured by sample groups, before and after ", params$norm, " normalisation.")) }`

```{r data_normalisation, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 16, eval = runChunk}
##### TMM normalsation. Trimmed mean of M-values (https://www.ncbi.nlm.nih.gov/pubmed/20196867) (TMM) is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. TMM is the recommended for most RNA-Seq data where the majority (more than half) of the genes are believed not differentially expressed between any pair of the samples. It adjusts for RNA composition effect, calculates scaling factors for the library sizes with calcNormFactors function using trimmed mean of M-values (TMM) between each pair of samples. Note, that the raw read counts are used to calculate the normalisation factors
if ( params$transform == "CPM" ) {
    
  y$noNorm <- edgeR::cpm(y, normalized.lib.sizes=FALSE, log=params$log, prior.count=0.25)
  y <- edgeR::calcNormFactors(y, method = params$norm)
  y$norm <- edgeR::cpm(y$transformed, normalized.lib.sizes=TRUE, log=params$log, prior.count=0.25)
    
##### Quantile normalsation (from https://www.biostars.org/p/296992/ )
} else if ( params$transform == "TPM" ) {
    
  ##### Normalisation using quantile method
  y$noNorm <- y$transformed
  y$transformed <- data.matrix(y$transformed)
      
  if ( tolower(params$norm) != "none" ) {
        
    y$norm  <- normalize.quantiles(y$transformed, copy = TRUE)
    colnames(y$norm) <- colnames(y$transformed)
    rownames(y$norm) <- rownames(y$transformed)
        
  } else {
        
      y$norm  <- y$transformed
  }
}

##### Set height scaling factor for plots containing normalised data plots
if ( tolower(params$norm) != "none" ) {
  
  norm.height = 2
} else {
  norm.height = 1
}
```

```{r data_normalisation_plots, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 8*norm.height, eval = runChunk}


##### Plot expression distribution of samples for unnormalised and normalised data
par(mfrow=c(norm.height,1), mar=c((max(nchar(colnames(y$noNorm)))+3)/2, 5, 3, 2))
    
##### Unnormalised data
boxplot(y$noNorm, las=2, col=targets.colour[[2]], main="", pch=".", las=3)
  title(main="Unnormalised data", ylab=params$transform)
legend("topright", legend=levels(factor(targetFile$Target)), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")
    
##### Normalised data
if ( tolower(params$norm) != "none" ) {
      
  boxplot(y$norm, las=2, col=targets.colour[[2]], main="", pch=".", las=3)
  title(main=paste0("Normalised data (", params$norm, ")"), ylab=params$transform)
  legend("topright", legend=levels(factor(targetFile$Target)), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")
}
    
##### Save the plot as pdf file
pdf(paste0(normalizePath(params$exprDir), "/", paste0(params$results_name, "_normalisation.pdf")), width=8, height=14)
par(mfrow=c(norm.height,1), mar=c(max(nchar(colnames(y$noNorm)))/2, 5, 3, 2))
    
##### Unnormalised data
boxplot(y$noNorm, las=2, col=targets.colour[[2]], main="", pch=".", las=3)
title(main="Unnormalised data", ylab=params$transform)
    legend("topright", legend=levels(factor(targetFile$Target)), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent", box.col="transparent")
      
##### Normalised data
if ( tolower(params$norm) != "none" ) {
      
  boxplot(y$norm, las=2, col=targets.colour[[2]], main="", pch=".", las=3)
  title(main=paste0("Normalised data (", params$norm, ")"), ylab=params$transform)
    legend("topright", legend=levels(factor(targetFile$Target)), fill=targets.colour[[1]], horiz=TRUE, bg = "transparent",box.col="transparent")
}
invisible(dev.off())
```

## Expression distribution patterns {.tabset}

### Plot

Plot presenting `r params$transform` data distribution for selected gene(s).




```{r expr_dist_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 5*norm.height, eval = runChunk}
##### Plot expression distribution in transfromed and normalised data for selected genes
##### Assigne colours to genes
genes.colour <- getGenesColours(genes)

##### Collect the most extreme density values for setting the x-axis and y-axis boundaries
den.x <- density(y$transformed[1,])$x
den.y <- density(y$transformed[1,])$y

for (i in 2:nrow(y$transformed)) {
  
  den <- density(y$transformed[i,])
  den.x <- sort(c(den.x, den$x))
  den.y <- sort(c(den.y, den$y))
}

par(mfrow=c(norm.height,1))

##### Transformed data for html report
plot(density(y$transformed[1,]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=genes.colour[1])
title(main="Transformed data", xlab=params$transform)
abline(v=0, lty=3)

for (i in 2:nrow(y$transformed)) {
  den <- density(y$transformed[i,])
  lines(den$x, den$y, lwd=2, col=genes.colour[i])
}
legend("topright", legend=levels(factor(rownames(y$transformed))), fill=genes.colour, bty="n", bg = "transparent")

#### Interactive genes distribution plot
test <- data.frame(gene = NA, tpm = NA, dens = NA)
for (i in 1:nrow(y$transformed)) {
test1 <- data.frame(gene = rownames(y$count)[i],tpm = density(y$transformed[i,])$x, dens = density(y$transformed[i,])$y)
test <- rbind(test, test1)
}
     
plotly::plot_ly(test, x = ~tpm, y = ~dens, type = 'scatter', mode = 'lines', color = ~gene) %>%
  plotly::layout(title = 'TPM distribution for slected genes',
         xaxis = list(title = 'tpm', range = c(den.x[1],den.x[length(den.x)])),
         yaxis = list (title = 'density', range = c(den.y[1],den.y[length(den.y)])))

##### Normalised data
if ( tolower(params$norm) != "none" ) {
  
  ##### Normalised data
  plot(density(y$norm[1,]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=genes.colour[1])
  title(main="Normalised data", xlab=params$transform)
  abline(v=0, lty=3)
  
  for (i in 2:nrow(y$norm)) {
    den <- density(y$norm[i,])
    lines(den$x, den$y, lwd=2, col=genes.colour[i])
  }
  legend("topright", legend=levels(factor(rownames(y$norm))), fill=genes.colour, bty="n", bg = "transparent")
}

##### Save the plot as pdf file
pdf(paste0(normalizePath(params$exprDir), "/", paste0(params$results_name, "_expr_distributions.pdf")), width=8, height=5*norm.height)
par(mfrow=c(norm.height,1))

##### Transformed data for PDF
plot(density(y$transformed[1,]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=genes.colour[1])
title(main="Transformed data", xlab=params$transform)
abline(v=0, lty=3)
  
for (i in 2:nrow(y$transformed)){
  den <- density(y$transformed[i,])
  lines(den$x, den$y, lwd=2, col=genes.colour[i])
}
legend("topright", legend=levels(factor(rownames(y$transformed))), fill=genes.colour, bty="n", bg = "transparent")
  
##### Normalised data
if ( tolower(params$norm) != "none" ) {
  
  ##### Normalised data
  plot(density(y$norm[1,]), lwd=2, xlim=c(den.x[1],den.x[length(den.x)]), ylim=c(den.y[1],den.y[length(den.y)]), las=2, main="", xlab="", col=genes.colour[1])
  title(main="Normalised data", xlab=params$transform)
  abline(v=0, lty=3)
      
  for (i in 2:nrow(y$norm)) {
    den <- density(y$norm[i,])
    lines(den$x, den$y, lwd=2, col=genes.colour[i])
  }
  legend("topright", legend=levels(factor(rownames(y$norm))), fill=genes.colour, bty="n", bg = "transparent")
} 
invisible(dev.off())
```

### Table

Table with `r params$transform` data values for each sample for selected genes.

**Transformed data**

```{r expr_dist_table_trans, comment = NA, message=FALSE, warning=FALSE, eval = runChunk}
##### Generate a table with expression values for selected genes
if ( nrow(y$transformed) < 25 ) {
  
  DT::datatable( data = round(t(y$transformed), digits = 1), filter="none", rownames = TRUE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption( style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
    DT::formatStyle( columns = names(t(y$transformed)), `font-size` = '12px', 'text-align' = 'center' )
  
} else {
  cat(paste0(nrow(y$transformed), " genes were selected. The tables is available only if less than 25 genes are selected!"))
}
```

**`r if ( tolower(params$norm) != "none" ) { c("Normalised data") }`**

```{r expr_dist_table_normalised, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, eval = runChunk}
##### Generate a table with expression values for selected genes
if ( tolower(params$norm) != "none" ) {
  
  if ( nrow(y$norm) < 25 ) {
    
    DT::datatable( data = round(t(y$norm), digits = 1), filter="none", rownames = TRUE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption( style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(t(y$norm)), `font-size` = '12px', 'text-align' = 'center' )
    
  } else {
    cat(paste0(nrow(y$norm), " genes were selected. The tables is available only if less than 25 genes are selected!"))
  }
}
```


***

## Addendum

<details>
<summary>Parameters</summary>
<font size="2">

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {
  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

</font>
</details>

<details>
<summary>Session info</summary>
<font size="2">

```{r sessioninfo, comment = NA}
devtools::session_info()
```

</font>
</details>
